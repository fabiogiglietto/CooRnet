% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/get_coord_shares_mongo.R
\name{get_coord_shares_mongo}
\alias{get_coord_shares_mongo}
\title{get_coord_shares_mongo}
\usage{
get_coord_shares_mongo(
  mongo_database,
  mongo_url = NULL,
  coordination_interval = NULL,
  parallel = FALSE,
  percentile_edge_weight = 0.9,
  clean_urls = FALSE,
  keep_ourl_only = FALSE,
  gtimestamps = FALSE
)
}
\arguments{
<<<<<<< HEAD
\item{mongo_database}{string: the name of the MongoDB used to host the collections.}

=======
>>>>>>> 53a2f1dc917dbc273685fabb8c71e8ef3c8336cd
\item{mongo_url}{string: address of the MongoDB server in standard URI Format. Set to NULL to avoid using mongo (default NULL)}

\item{coordination_interval}{a threshold in seconds that defines a coordinated share. Given a dataset of CrowdTangle shares, this threshold is automatically estimated by the estimate_coord_interval interval function. Alternatively it can be manually passed to the function in seconds}

\item{parallel}{enables parallel processing to speed up the process taking advantage of multiple cores (default FALSE). The number of cores is automatically set to all the available cores minus one}

\item{percentile_edge_weight}{defines the percentile of the edge distribution to keep in order to identify a network of coordinated entities. In other terms, this value determines the minimum number of times that two entities had to coordinate in order to be considered part of a network. (default 0.90)}

\item{clean_urls}{clean the URLs from the tracking parameters (default FALSE)}

\item{keep_ourl_only}{restrict the analysis to ct shares links matching the original URLs (default=FALSE)}

\item{gtimestamps}{add timestamps of the fist and last coordinated shares on each node. Slow on large networks (default=FALSE)}

<<<<<<< HEAD
=======
\item{ct_shares.df}{the data.frame of link posts resulting from the function get_ctshares}

>>>>>>> 53a2f1dc917dbc273685fabb8c71e8ef3c8336cd
\item{mongo_collection}{string: name of the MongoDB collection where the shares have been saved. Set to NULL to avoid using mongo (default NULL)}
}
\value{
A list (results_list) containing four objects: 1. The input data.table (ct_shares.dt) of shares with an additional boolean variable (coordinated) that identifies coordinated shares, 2. An igraph graph (highly_connected_g) with networks of coordinated entities whose edges also contains a t_coord_share attribute (vector) reporting the timestamps of every time the edge was detected as coordinated sharing, 3. A dataframe with a list of coordinated entities (highly_connected_coordinated_entities) with respective name (the account url), number of shares performed, average subscriber count, platform, account name, if the account name changed, if the account is verified, account handle, degree and component number
}
\description{
<<<<<<< HEAD
Given a dataset of CrowdTangle shares on a MongoDB database and a time threshold, this function detects networks of entities (pages, accounts and groups) that performed coordinated link sharing behavior
}
\examples{
output <- get_coord_shares_mongo(mongo_database)

output <- get_coord_shares_mongo(mongo_database = mongo_database, coordination_interval = coordination.interval, percentile_edge_weight=0.9, clean_urls=FALSE, keep_ourl_only=FALSE, gtimestamps=FALSE)
=======
Given a dataset of CrowdTangle shares and a time threshold, this function detects networks of entities (pages, accounts and groups) that performed coordinated link sharing behavior
}
\examples{
output <- get_coord_shares(ct_shares.df)

output <- get_coord_shares(ct_shares.df = ct_shares.df, coordination_interval = coordination.interval, percentile_edge_weight=0.9, clean_urls=FALSE, keep_ourl_only=FALSE, gtimestamps=FALSE)
>>>>>>> 53a2f1dc917dbc273685fabb8c71e8ef3c8336cd

# Extract the outputs
get_outputs(output)

# Save the data frame of CrowdTangle shares marked with the “is_coordinated” column
write.csv(ct_shares_marked.df, file=“ct_shares_marked.df.csv”)

# Save the graph in a Gephi readable format
library(igraph)
write.graph(highly_connected_g, file="highly_connected_g.graphml", format = "graphml")

# Save the data frame with the information about the highly connected coordinated entities
write.csv(highly_connected_coordinated_entities, file=“highly_connected_coordinated_entities.csv”)

}
